{"version":3,"sources":["../src/ajvErrorNormalizer.ts"],"names":[],"mappings":"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","sourcesContent":["import { AdditionalPropertiesParams, ComparisonParams, DependenciesParams, ErrorObject, TypeParams } from \"ajv\"\n\nexport function normaliseErrorMessages(errors: Array<ErrorObject>, schemeData: object) {\n  const printer = new SchemeErrorPrinter(schemeData)\n  return \"Configuration is invalid.\\n\" +\n    filterErrors(errors)\n      .map(it => \" - \" + indent(printer.formatValidationError(it), \"   \", false))\n      .join(\"\\n\")\n}\n\n//tslint:disable-next-line:no-empty-interface\ninterface Scheme {\n  // to ensure that proper arg is passed\n}\n\nclass SchemeErrorPrinter {\n  constructor(readonly schemeData: Scheme) {\n  }\n\n  formatValidationError(error: ErrorObject) {\n    const dataPath = `configuration${error.dataPath}`\n    if (error.keyword === \"additionalProperties\") {\n      return `${dataPath} has an unknown property '${(error.params as AdditionalPropertiesParams).additionalProperty}'. These properties are valid:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"oneOf\" || error.keyword === \"anyOf\") {\n      const children = (error as any).children\n      if (children && children.length > 0) {\n        // use set to remove duplicated messages like \"should be an object.\"\n        return `${dataPath} should be one of these:\\n${this.getSchemaPartText(error.parentSchema)}\\n` +\n          `Details:\\n${Array.from(new Set(children.map((it: ErrorObject) => \" * \" + indent(this.formatValidationError(it), \"   \", false)))).join(\"\\n\")}`\n      }\n      return `${dataPath} should be one of these:\\n${this.getSchemaPartText(error.parentSchema)}`\n\n    }\n    else if (error.keyword === \"enum\") {\n      if (error.parentSchema && (error.parentSchema as any).enum && (error.parentSchema as any).enum.length === 1) {\n        return `${dataPath} should be ${this.getSchemaPartText(error.parentSchema)}`\n      }\n      return `${dataPath} should be one of these:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"allOf\") {\n      return `${dataPath} should be:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"type\") {\n      switch ((error.params as TypeParams).type) {\n        case \"object\":\n          return `${dataPath} should be an object.`\n        case \"string\":\n          return `${dataPath} should be a string.`\n        case \"boolean\":\n          return `${dataPath} should be a boolean.`\n        case \"number\":\n          return `${dataPath} should be a number.`\n        case \"array\":\n          return `${dataPath} should be an array:\\n${this.getSchemaPartText(error.parentSchema)}`\n      }\n      return `${dataPath} should be ${(error.params as TypeParams).type}:\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n    else if (error.keyword === \"instanceof\") {\n      return `${dataPath} should be an instance of ${this.getSchemaPartText(error.parentSchema)}.`\n    }\n    else if (error.keyword === \"required\") {\n      const missingProperty = (error.params as DependenciesParams).missingProperty.replace(/^\\./, \"\")\n      return `${dataPath} misses the property '${missingProperty}'.\\n${this.getSchemaPartText(error.parentSchema, [\"properties\", missingProperty])}`\n    }\n    else if (error.keyword === \"minLength\" || error.keyword === \"minItems\") {\n      if ((error.params as ComparisonParams).limit === 1) {\n        return `${dataPath} should not be empty.`\n      }\n      else {\n        return `${dataPath} ${error.message}`\n      }\n    }\n    else if (error.keyword === \"absolutePath\") {\n      const baseMessage = `${dataPath}: ${error.message}`\n      if (dataPath === \"configuration.output.filename\") {\n        return `${baseMessage}\\n` +\n          \"Please use output.path to specify absolute path and output.filename for the file name.\"\n      }\n      return baseMessage\n    }\n    else {\n      // eslint-disable-line no-fallthrough\n      return `${dataPath} ${error.message} (${JSON.stringify(error, null, 2)}).\\n${this.getSchemaPartText(error.parentSchema)}`\n    }\n  }\n\n  private getSchemaPart(path: string) {\n    const pathList = path.split(\"/\").slice(0, path.length)\n    let schemaPart = this.schemeData as any\n    for (let i = 1; i < pathList.length; i++) {\n      const inner = schemaPart[pathList[i]]\n      if (inner) {\n        schemaPart = inner\n      }\n    }\n    return schemaPart\n  }\n\n  private getSchemaPartText(schemaPart: any, additionalPath: Array<string> | null = null) {\n    if (additionalPath != null) {\n      for (const p of additionalPath) {\n        const inner = schemaPart[p]\n        if (inner) {\n          schemaPart = inner\n        }\n      }\n    }\n\n    while (schemaPart.$ref != null) {\n      schemaPart = this.getSchemaPart(schemaPart.$ref)\n    }\n\n    let schemaText = this.formatSchema(schemaPart)\n    let description = schemaPart.description\n    if (description != null) {\n      description = description.trim()\n      const twoLineBreakPosition = description.indexOf(\"\\n\\n\")\n      description = twoLineBreakPosition < 0 ? description : description.substring(0, twoLineBreakPosition)\n      schemaText += `\\n${description}\\n`\n    }\n    return schemaText\n  }\n\n  private formatSchema(schema: any, prevSchemas?: any) {\n    prevSchemas = prevSchemas || []\n\n    const formatInnerSchema = (innerSchema: any, isAddSelf = false): string => {\n      if (!isAddSelf) {\n        return this.formatSchema(innerSchema, prevSchemas)\n      }\n      if (prevSchemas.indexOf(innerSchema) >= 0) {\n        return \"(recursive)\"\n      }\n      return this.formatSchema(innerSchema, prevSchemas.concat(schema))\n    }\n\n    if (schema.type === \"string\") {\n      if (schema.minLength === 1) {\n        return \"non-empty string\"\n      }\n      else if (schema.minLength > 1) {\n        return `string (min length ${schema.minLength})`\n      }\n      else {\n        return \"string\"\n      }\n    }\n    else if (schema.type === \"boolean\") {\n      return \"boolean\"\n    }\n    else if (schema.type === \"number\") {\n      return \"number\"\n    }\n    else if (schema.type === \"object\") {\n      if (schema.properties) {\n        const required = schema.required || []\n        return `object { ${Object.keys(schema.properties).map(property => {\n          if (required.indexOf(property) < 0) {\n            return property + \"?\"\n          }\n          return property\n        }).concat(schema.additionalProperties ? [\"...\"] : []).join(\", \")} }`\n      }\n      if (schema.additionalProperties) {\n        return `object { <key>: ${formatInnerSchema(schema.additionalProperties)} }`\n      }\n      return \"object\"\n    }\n    else if (schema.type === \"array\") {\n      return `[${formatInnerSchema(schema.items)}]`\n    }\n\n    switch (schema.instanceof) {\n      case \"Function\":\n        return \"function\"\n      case \"RegExp\":\n        return \"RegExp\"\n    }\n\n    if (schema.$ref != null) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true)\n    }\n    if (schema.allOf) {\n      return schema.allOf.map(formatInnerSchema).join(\" & \")\n    }\n    if (schema.oneOf) {\n      return schema.oneOf.map(formatInnerSchema).join(\" | \")\n    }\n    if (schema.anyOf) {\n      return schema.anyOf.map(formatInnerSchema).join(\" | \")\n    }\n    if (schema.enum) {\n      return schema.enum.map((it: object) => JSON.stringify(it)).join(\" | \")\n    }\n    return JSON.stringify(schema, null, 2)\n  }\n}\n\nfunction indent(str: string, prefix: string, isFirstLine: boolean) {\n  if (isFirstLine) {\n    return prefix + str.replace(/\\n(?!$)/g, \"\\n\" + prefix)\n  }\n  else {\n    return str.replace(/\\n(?!$)/g, `\\n${prefix}`)\n  }\n}\n\nfunction filterErrors(errors: Array<ErrorObject>) {\n  let newErrors: Array<any> = []\n  for (const error of errors) {\n    const dataPath = error.dataPath\n    let children: Array<ErrorObject> = []\n    newErrors = newErrors.filter(oldError => {\n      if (!oldError.dataPath.includes(dataPath)) {\n        return true\n      }\n\n      if (oldError.children != null) {\n        children = children.concat(oldError.children.slice(0))\n      }\n      oldError.children = null\n      children.push(oldError)\n      return false\n    })\n\n    if (children.length > 0) {\n      (error as any).children = children\n    }\n    newErrors.push(error)\n  }\n  return newErrors\n}"],"sourceRoot":""}
