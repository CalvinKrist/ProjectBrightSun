{"version":3,"sources":["../../src/targets/LinuxTargetHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import { asArray, isEmptyOrSpaces, log } from \"builder-util\"\nimport { outputFile } from \"fs-extra-p\"\nimport { Lazy } from \"lazy-val\"\nimport * as path from \"path\"\nimport { LinuxTargetSpecificOptions } from \"..\"\nimport { LinuxPackager } from \"../linuxPackager\"\nimport { IconInfo } from \"../platformPackager\"\nimport { getTemplatePath } from \"../util/pathManager\"\n\nexport const installPrefix = \"/opt\"\n\nexport class LinuxTargetHelper {\n  private readonly iconPromise = new Lazy(() => this.computeDesktopIcons())\n\n  maxIconPath: string | null = null\n\n  constructor(private packager: LinuxPackager) {\n  }\n\n  get icons(): Promise<Array<IconInfo>> {\n    return this.iconPromise.value\n  }\n\n  // must be name without spaces and other special characters, but not product name used\n  private async computeDesktopIcons(): Promise<Array<IconInfo>> {\n    const packager = this.packager\n    const iconDir = packager.platformSpecificBuildOptions.icon\n    const sources = [iconDir == null ? \"icons\" : iconDir]\n\n    const commonConfiguration = packager.config\n    let icnsPath = (commonConfiguration.mac || {}).icon || commonConfiguration.icon\n    if (icnsPath != null) {\n      if (!icnsPath.endsWith(\".icns\")) {\n        icnsPath += \".icns\"\n      }\n      sources.push(icnsPath)\n    }\n\n    sources.push(\"icon.icns\")\n\n    sources.push(path.join(getTemplatePath(\"linux\"), \"electron-icons\"))\n\n    const result = await packager.resolveIcon(sources, \"set\")\n    this.maxIconPath = result[result.length - 1].file\n    return result\n  }\n\n  getDescription(options: LinuxTargetSpecificOptions) {\n    return options.description || this.packager.appInfo.description\n  }\n\n  async writeDesktopEntry(targetSpecificOptions: LinuxTargetSpecificOptions, exec?: string, destination?: string | null, extra?: { [key: string]: string; }): Promise<string> {\n    const data = await this.computeDesktopEntry(targetSpecificOptions, exec, extra)\n    const file = destination || await this.packager.getTempFile(`${this.packager.appInfo.productFilename}.desktop`)\n    await outputFile(file, data)\n    return file\n  }\n\n  async computeDesktopEntry(targetSpecificOptions: LinuxTargetSpecificOptions, exec?: string, extra?: { [key: string]: string; }): Promise<string> {\n    if (exec != null && exec.length === 0) {\n      throw new Error(\"Specified exec is empty\")\n    }\n\n    const packager = this.packager\n    const appInfo = packager.appInfo\n\n    const productFilename = appInfo.productFilename\n\n    const desktopMeta: any = {\n      Name: appInfo.productName,\n      Comment: this.getDescription(targetSpecificOptions),\n      Exec: exec == null ? `\"${installPrefix}/${productFilename}/${packager.executableName}\" %U` : exec,\n      Terminal: \"false\",\n      Type: \"Application\",\n      Icon: packager.executableName,\n      // https://askubuntu.com/questions/367396/what-represent-the-startupwmclass-field-of-a-desktop-file\n      // must be set to package.json name (because it is Electron set WM_CLASS)\n      // to get WM_CLASS of running window: xprop WM_CLASS\n      // StartupWMClass doesn't work for unicode\n      // https://github.com/electron/electron/blob/2-0-x/atom/browser/native_window_views.cc#L226\n      StartupWMClass: appInfo.productName,\n      ...extra,\n      ...targetSpecificOptions.desktop,\n    }\n\n    const mimeTypes: Array<string> = asArray(targetSpecificOptions.mimeTypes)\n    for (const fileAssociation of packager.fileAssociations) {\n      if (fileAssociation.mimeType != null) {\n        mimeTypes.push(fileAssociation.mimeType)\n      }\n    }\n\n    for (const protocol of asArray(packager.config.protocols).concat(asArray(packager.platformSpecificBuildOptions.protocols))) {\n      for (const scheme of asArray(protocol.schemes)) {\n        mimeTypes.push(`x-scheme-handler/${scheme}`)\n      }\n    }\n\n    if (mimeTypes.length !== 0) {\n      desktopMeta.MimeType = mimeTypes.join(\";\") + \";\"\n    }\n\n    let category = targetSpecificOptions.category\n    if (isEmptyOrSpaces(category)) {\n      const macCategory = (packager.config.mac || {}).category\n      if (macCategory != null) {\n        category = macToLinuxCategory[macCategory]\n      }\n\n      if (category == null) {\n        // https://github.com/develar/onshape-desktop-shell/issues/48\n        if (macCategory != null) {\n          log.warn({macCategory}, \"cannot map macOS category to Linux. If possible mapping is known for you, please file issue to add it.\")\n        }\n        log.warn({\n          reason: \"linux.category is not set and cannot map from macOS\",\n          docs: \"https://electron.build/configuration/configuration#LinuxBuildOptions-category\",\n        }, \"application Linux category is set to default \\\"Utility\\\"\")\n        category = \"Utility\"\n      }\n    }\n    desktopMeta.Categories = `${category}${category.endsWith(\";\") ? \"\" : \";\"}`\n\n    let data = `[Desktop Entry]`\n    for (const name of Object.keys(desktopMeta)) {\n      data += `\\n${name}=${desktopMeta[name]}`\n    }\n    data += \"\\n\"\n    return data\n  }\n}\n\nconst macToLinuxCategory: any = {\n  \"public.app-category.graphics-design\": \"Graphics\",\n  \"public.app-category.developer-tools\": \"Development\",\n  \"public.app-category.education\": \"Education\",\n  \"public.app-category.games\": \"Game\",\n  \"public.app-category.video\": \"Video;AudioVideo\",\n  \"public.app-category.utilities\": \"Utility\",\n  \"public.app-category.social-networking\": \"Network;Chat\",\n  \"public.app-category.finance\": \"Office;Finance\",\n}"],"sourceRoot":""}
