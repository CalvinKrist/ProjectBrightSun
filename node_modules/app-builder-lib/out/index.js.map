{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { executeFinally } from \"builder-util/out/promise\"\nimport { PublishOptions } from \"electron-publish/out/publisher\"\nimport { log, InvalidConfigurationError } from \"builder-util\"\nimport { asArray } from \"builder-util-runtime\"\nimport { Packager } from \"./packager\"\nimport { PackagerOptions } from \"./packagerApi\"\nimport { resolveFunction } from \"./platformPackager\"\nimport { PublishManager } from \"./publish/PublishManager\"\n\nexport { Packager, BuildResult } from \"./packager\"\nexport { PackagerOptions, ArtifactCreated } from \"./packagerApi\"\nexport { TargetConfiguration, Platform, Target, DIR_TARGET, BeforeBuildContext, SourceRepositoryInfo, TargetSpecificOptions, TargetConfigType, DEFAULT_TARGET, CompressionLevel } from \"./core\"\nexport { getArchSuffix, Arch, archFromString } from \"builder-util\"\nexport { Configuration, AfterPackContext, MetadataDirectories } from \"./configuration\"\nexport { ElectronDownloadOptions, ElectronPlatformName } from \"./electron/electron-download\"\nexport { PlatformSpecificBuildOptions, AsarOptions, FileSet, Protocol, ReleaseInfo } from \"./options/PlatformSpecificBuildOptions\"\nexport { FileAssociation } from \"./options/FileAssociation\"\nexport { MacConfiguration, DmgOptions, MasConfiguration, MacOsTargetName, PkgOptions, DmgContent, DmgWindow } from \"./options/macOptions\"\nexport { WindowsConfiguration } from \"./options/winOptions\"\nexport { AppXOptions } from \"./options/AppXOptions\"\nexport { MsiOptions } from \"./options/MsiOptions\"\nexport { CommonWindowsInstallerConfiguration } from \"./options/CommonWindowsInstallerConfiguration\"\nexport { NsisOptions, NsisWebOptions, PortableOptions, CommonNsisOptions } from \"./targets/nsis/nsisOptions\"\nexport { LinuxConfiguration, DebOptions, CommonLinuxOptions, LinuxTargetSpecificOptions, AppImageOptions } from \"./options/linuxOptions\"\nexport { SnapOptions } from \"./options/SnapOptions\"\nexport { Metadata, AuthorMetadata, RepositoryInfo } from \"./options/metadata\"\nexport { AppInfo } from \"./appInfo\"\nexport { SquirrelWindowsOptions } from \"./options/SquirrelWindowsOptions\"\nexport { WindowsSignOptions, CustomWindowsSignTaskConfiguration, WindowsSignTaskConfiguration, CustomWindowsSign, FileCodeSigningInfo, CertificateFromStoreInfo } from \"./windowsCodeSign\"\nexport { CancellationToken, ProgressInfo } from \"builder-util-runtime\"\nexport { PublishOptions, UploadTask } from \"electron-publish\"\nexport { PublishManager } from \"./publish/PublishManager\"\nexport { PlatformPackager } from \"./platformPackager\"\nexport { Framework, PrepareApplicationStageDirectoryOptions } from \"./Framework\"\nexport { buildForge, ForgeOptions } from \"./forge-maker\"\n\nconst expectedOptions = new Set([\"publish\", \"targets\", \"mac\", \"win\", \"linux\", \"projectDir\", \"platformPackagerFactory\", \"config\", \"effectiveOptionComputed\", \"prepackaged\"])\n\nexport function checkBuildRequestOptions(options: PackagerOptions & PublishOptions) {\n  for (const optionName of Object.keys(options)) {\n    if (!expectedOptions.has(optionName) && (options as any)[optionName] !== undefined) {\n      throw new InvalidConfigurationError(`Unknown option \"${optionName}\"`)\n    }\n  }\n}\n\nexport function build(options: PackagerOptions & PublishOptions, packager: Packager = new Packager(options)): Promise<Array<string>> {\n  checkBuildRequestOptions(options)\n\n  const publishManager = new PublishManager(packager, options)\n  const sigIntHandler = () => {\n    log.warn(\"cancelled by SIGINT\")\n    packager.cancellationToken.cancel()\n    publishManager.cancelTasks()\n  }\n  process.once(\"SIGINT\", sigIntHandler)\n\n  const promise = packager.build()\n    .then(async buildResult => {\n      const afterAllArtifactBuild = resolveFunction(buildResult.configuration.afterAllArtifactBuild, \"afterAllArtifactBuild\")\n      if (afterAllArtifactBuild != null) {\n        const newArtifacts = asArray(await Promise.resolve(afterAllArtifactBuild(buildResult)))\n        if (newArtifacts.length === 0 || !publishManager.isPublish) {\n          return buildResult.artifactPaths\n        }\n\n        const publishConfigurations = await publishManager.getGlobalPublishConfigurations()\n        if (publishConfigurations == null || publishConfigurations.length === 0) {\n          return buildResult.artifactPaths\n        }\n\n        for (const newArtifact of newArtifacts) {\n          buildResult.artifactPaths.push(newArtifact)\n          for (const publishConfiguration of publishConfigurations) {\n            publishManager.scheduleUpload(publishConfiguration, {\n              file: newArtifact,\n              arch: null\n            }, packager.appInfo)\n          }\n        }\n      }\n      return buildResult.artifactPaths\n    })\n\n  return executeFinally(promise, isErrorOccurred => {\n    let promise: Promise<any>\n    if (isErrorOccurred) {\n      publishManager.cancelTasks()\n      promise = Promise.resolve(null)\n    }\n    else {\n      promise = publishManager.awaitTasks()\n    }\n\n    return promise\n      .then(() => process.removeListener(\"SIGINT\", sigIntHandler))\n  })\n}"],"sourceRoot":""}
