{"version":3,"sources":["../../src/asar/asarUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import { AsyncTaskManager, log } from \"builder-util\"\nimport { FileCopier, Filter, MAX_FILE_REQUESTS } from \"builder-util/out/fs\"\nimport { symlink } from \"fs\"\nimport { createReadStream, createWriteStream, ensureDir, readFile, Stats, writeFile } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport { AsarOptions } from \"..\"\nimport { Packager } from \"../packager\"\nimport { PlatformPackager } from \"../platformPackager\"\nimport { getDestinationPath, ResolvedFileSet } from \"../util/appFileCopier\"\nimport { AsarFilesystem, Node } from \"./asar\"\nimport { detectUnpackedDirs } from \"./unpackDetector\"\n\nconst pickle = require(\"chromium-pickle-js\")\n\n/** @internal */\nexport class AsarPackager {\n  private readonly fs = new AsarFilesystem(this.src)\n  private readonly outFile: string\n  private readonly unpackedDest: string\n\n  constructor(private readonly src: string, private readonly destination: string, private readonly options: AsarOptions, private readonly unpackPattern: Filter | null) {\n    this.outFile = path.join(destination, \"app.asar\")\n    this.unpackedDest = `${this.outFile}.unpacked`\n  }\n\n  // sort files to minimize file change (i.e. asar file is not changed dramatically on small change)\n  async pack(fileSets: Array<ResolvedFileSet>, packager: PlatformPackager<any>) {\n    if (this.options.ordering != null) {\n      // ordering doesn't support transformed files, but ordering is not used functionality - wait user report to fix it\n      await order(fileSets[0].files, this.options.ordering, fileSets[0].src)\n    }\n    await ensureDir(path.dirname(this.outFile))\n    const unpackedFileIndexMap = new Map<ResolvedFileSet, Set<number>>()\n    for (const fileSet of fileSets) {\n      unpackedFileIndexMap.set(fileSet, await this.createPackageFromFiles(fileSet, packager.info))\n    }\n    await this.writeAsarFile(fileSets, unpackedFileIndexMap)\n  }\n\n  private async createPackageFromFiles(fileSet: ResolvedFileSet, packager: Packager) {\n    const metadata = fileSet.metadata\n    // search auto unpacked dir\n    const unpackedDirs = new Set<string>()\n    const rootForAppFilesWithoutAsar = path.join(this.destination, \"app\")\n\n    if (this.options.smartUnpack !== false) {\n      await detectUnpackedDirs(fileSet, unpackedDirs, this.unpackedDest, rootForAppFilesWithoutAsar)\n    }\n\n    const dirToCreateForUnpackedFiles = new Set<string>(unpackedDirs)\n\n    const correctDirNodeUnpackedFlag = async (filePathInArchive: string, dirNode: Node) => {\n      for (const dir of unpackedDirs) {\n        if (filePathInArchive.length > (dir.length + 2) && filePathInArchive[dir.length] === path.sep && filePathInArchive.startsWith(dir)) {\n          dirNode.unpacked = true\n          unpackedDirs.add(filePathInArchive)\n          // not all dirs marked as unpacked after first iteration - because node module dir can be marked as unpacked after processing node module dir content\n          // e.g. node-notifier/example/advanced.js processed, but only on process vendor/terminal-notifier.app module will be marked as unpacked\n          await ensureDir(path.join(this.unpackedDest, filePathInArchive))\n          break\n        }\n      }\n    }\n\n    const transformedFiles = fileSet.transformedFiles\n    const taskManager = new AsyncTaskManager(packager.cancellationToken)\n    const fileCopier = new FileCopier()\n\n    let currentDirNode: Node | null = null\n    let currentDirPath: string | null = null\n\n    const unpackedFileIndexSet = new Set<number>()\n\n    for (let i = 0, n = fileSet.files.length; i < n; i++) {\n      const file = fileSet.files[i]\n      const stat = metadata.get(file)\n      if (stat == null) {\n        continue\n      }\n\n      const pathInArchive = path.relative(rootForAppFilesWithoutAsar, getDestinationPath(file, fileSet))\n\n      if (stat.isSymbolicLink()) {\n        const s = (stat as any)\n        this.fs.getOrCreateNode(pathInArchive).link = s.relativeLink\n        s.pathInArchive = pathInArchive\n        unpackedFileIndexSet.add(i)\n        continue\n      }\n\n      let fileParent = path.dirname(pathInArchive)\n      if (fileParent === \".\") {\n        fileParent = \"\"\n      }\n\n      if (currentDirPath !== fileParent) {\n        if (fileParent.startsWith(\"..\")) {\n          throw new Error(`Internal error: path must not start with \"..\": ${fileParent}`)\n        }\n\n        currentDirPath = fileParent\n        currentDirNode = this.fs.getOrCreateNode(fileParent)\n        // do not check for root\n        if (fileParent !== \"\" && !currentDirNode.unpacked) {\n          if (unpackedDirs.has(fileParent)) {\n            currentDirNode.unpacked = true\n          }\n          else {\n            await correctDirNodeUnpackedFlag(fileParent, currentDirNode)\n          }\n        }\n      }\n\n      const dirNode = currentDirNode!\n      const newData = transformedFiles == null ? null : transformedFiles.get(i)\n      const isUnpacked = dirNode.unpacked || (this.unpackPattern != null && this.unpackPattern(file, stat))\n      this.fs.addFileNode(file, dirNode, newData == null ? stat.size : Buffer.byteLength(newData), isUnpacked, stat)\n      if (isUnpacked) {\n        if (!dirNode.unpacked && !dirToCreateForUnpackedFiles.has(fileParent)) {\n          dirToCreateForUnpackedFiles.add(fileParent)\n          await ensureDir(path.join(this.unpackedDest, fileParent))\n        }\n\n        const unpackedFile = path.join(this.unpackedDest, pathInArchive)\n        taskManager.addTask(copyFileOrData(fileCopier, newData, file, unpackedFile, stat))\n        if (taskManager.tasks.length > MAX_FILE_REQUESTS) {\n          await taskManager.awaitTasks()\n        }\n\n        unpackedFileIndexSet.add(i)\n      }\n    }\n\n    if (taskManager.tasks.length > 0) {\n      await taskManager.awaitTasks()\n    }\n\n    return unpackedFileIndexSet\n  }\n\n  private writeAsarFile(fileSets: Array<ResolvedFileSet>, unpackedFileIndexMap: Map<ResolvedFileSet, Set<number>>): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const headerPickle = pickle.createEmpty()\n      headerPickle.writeString(JSON.stringify(this.fs.header))\n      const headerBuf = headerPickle.toBuffer()\n\n      const sizePickle = pickle.createEmpty()\n      sizePickle.writeUInt32(headerBuf.length)\n\n      const sizeBuf = sizePickle.toBuffer()\n      const writeStream = createWriteStream(this.outFile)\n      writeStream.on(\"error\", reject)\n      writeStream.on(\"close\", resolve)\n      writeStream.write(sizeBuf)\n\n      let fileSetIndex = 0\n\n      let files = fileSets[0].files\n      let metadata = fileSets[0].metadata\n      let transformedFiles = fileSets[0].transformedFiles\n      let unpackedFileIndexSet = unpackedFileIndexMap.get(fileSets[0])!!\n      const w = (index: number) => {\n        while (true) {\n          if (index >= files.length) {\n            if (++fileSetIndex >= fileSets.length) {\n              writeStream.end()\n              return\n            }\n            else {\n              files = fileSets[fileSetIndex].files\n              metadata = fileSets[fileSetIndex].metadata\n              transformedFiles = fileSets[fileSetIndex].transformedFiles\n              unpackedFileIndexSet = unpackedFileIndexMap.get(fileSets[fileSetIndex])!!\n              index = 0\n            }\n          }\n\n          if (!unpackedFileIndexSet.has(index)) {\n            break\n          }\n          else {\n            const stat = metadata.get(files[index])\n            if (stat != null && stat.isSymbolicLink()) {\n              symlink((stat as any).linkRelativeToFile, path.join(this.unpackedDest, (stat as any).pathInArchive), () => w(index + 1))\n              return\n            }\n          }\n          index++\n        }\n\n        const data = transformedFiles == null ? null : transformedFiles.get(index)\n        const file = files[index]\n        if (data !== null && data !== undefined) {\n          writeStream.write(data, () => w(index + 1))\n          return\n        }\n\n        // https://github.com/yarnpkg/yarn/pull/3539\n        const stat = metadata.get(file)\n        if (stat != null && stat.size < (2 * 1024 * 1024)) {\n          readFile(file)\n            .then(it => {\n              writeStream.write(it, () => w(index + 1))\n            })\n            .catch(e => reject(`Cannot read file ${file}: ${e.stack || e}`))\n        }\n        else {\n          const readStream = createReadStream(file)\n          readStream.on(\"error\", reject)\n          readStream.once(\"end\", () => w(index + 1))\n          readStream.pipe(writeStream, {\n            end: false\n          })\n        }\n      }\n\n      writeStream.write(headerBuf, () => w(0))\n    })\n  }\n}\n\nasync function order(filenames: Array<string>, orderingFile: string, src: string) {\n  const orderingFiles = (await readFile(orderingFile, \"utf8\")).split(\"\\n\").map(line => {\n    if (line.indexOf(\":\") !== -1) {\n      line = line.split(\":\").pop()!\n    }\n    line = line.trim()\n    if (line[0] === \"/\") {\n      line = line.slice(1)\n    }\n    return line\n  })\n\n  const ordering: Array<string> = []\n  for (const file of orderingFiles) {\n    const pathComponents = file.split(path.sep)\n    for (const pathComponent of pathComponents) {\n      ordering.push(path.join(src, pathComponent))\n    }\n  }\n\n  const sortedFiles: Array<string> = []\n  let missing = 0\n  const total = filenames.length\n  for (const file of ordering) {\n    if (!sortedFiles.includes(file) && filenames.includes(file)) {\n      sortedFiles.push(file)\n    }\n  }\n  for (const file of filenames) {\n    if (!sortedFiles.includes(file)) {\n      sortedFiles.push(file)\n      missing += 1\n    }\n  }\n  log.info({coverage: ((total - missing) / total * 100)}, \"ordering files in ASAR archive\")\n  return sortedFiles\n}\n\nfunction copyFileOrData(fileCopier: FileCopier, data: string | Buffer | undefined | null, source: string, destination: string, stats: Stats) {\n  if (data == null) {\n    return fileCopier.copy(source, destination, stats)\n  }\n  else {\n    return writeFile(destination, data)\n  }\n}"],"sourceRoot":""}
