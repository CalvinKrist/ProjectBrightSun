{"version":3,"sources":["../../src/asar/unpackDetector.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { log } from \"builder-util\"\nimport { CONCURRENCY } from \"builder-util/out/fs\"\nimport { ensureDir } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport { NODE_MODULES_PATTERN } from \"../fileTransformer\"\nimport { getDestinationPath, ResolvedFileSet } from \"../util/appFileCopier\"\n\nconst isBinaryFile: any = BluebirdPromise.promisify(require(\"isbinaryfile\"))\n\nfunction addValue(map: Map<string, Array<string>>, key: string, value: string) {\n  let list = map.get(key)\n  if (list == null) {\n    list = [value]\n    map.set(key, list)\n  }\n  else {\n    list.push(value)\n  }\n}\n\nexport function isLibOrExe(file: string): boolean {\n  return file.endsWith(\".dll\") || file.endsWith(\".exe\") || file.endsWith(\".dylib\") || file.endsWith(\".so\")\n}\n\n/** @internal */\nexport async function detectUnpackedDirs(fileSet: ResolvedFileSet, autoUnpackDirs: Set<string>, unpackedDest: string, rootForAppFilesWithoutAsar: string) {\n  const dirToCreate = new Map<string, Array<string>>()\n  const metadata = fileSet.metadata\n\n  function addParents(child: string, root: string) {\n    child = path.dirname(child)\n    if (autoUnpackDirs.has(child)) {\n      return\n    }\n\n    do {\n      autoUnpackDirs.add(child)\n      const p = path.dirname(child)\n      // create parent dir to be able to copy file later without directory existence check\n      addValue(dirToCreate, p, path.basename(child))\n\n      if (child === root || p === root || autoUnpackDirs.has(p)) {\n        break\n      }\n      child = p\n    }\n    while (true)\n\n    autoUnpackDirs.add(root)\n  }\n\n  for (let i = 0, n = fileSet.files.length; i < n; i++) {\n    const file = fileSet.files[i]\n    const index = file.lastIndexOf(NODE_MODULES_PATTERN)\n    if (index < 0) {\n      continue\n    }\n\n    let nextSlashIndex = file.indexOf(path.sep, index + NODE_MODULES_PATTERN.length + 1)\n    if (nextSlashIndex < 0) {\n      continue\n    }\n\n    if (file[index + NODE_MODULES_PATTERN.length] === \"@\") {\n      nextSlashIndex = file.indexOf(path.sep, nextSlashIndex + 1)\n    }\n\n    if (!metadata.get(file)!.isFile()) {\n      continue\n    }\n\n    const packageDir = file.substring(0, nextSlashIndex)\n    const packageDirPathInArchive = path.relative(rootForAppFilesWithoutAsar, getDestinationPath(packageDir, fileSet))\n    const pathInArchive = path.relative(rootForAppFilesWithoutAsar, getDestinationPath(file, fileSet))\n    if (autoUnpackDirs.has(packageDirPathInArchive)) {\n      // if package dir is unpacked, any file also unpacked\n      addParents(pathInArchive, packageDirPathInArchive)\n      continue\n    }\n\n    // https://github.com/electron-userland/electron-builder/issues/2679\n    let shouldUnpack = false\n    if (isLibOrExe(file)) {\n      shouldUnpack = true\n    }\n    else if (!file.includes(\".\", nextSlashIndex) && path.extname(file) === \"\") {\n      shouldUnpack = await isBinaryFile(file)\n    }\n\n    if (!shouldUnpack) {\n      continue\n    }\n\n    if (log.isDebugEnabled) {\n      log.debug({file: pathInArchive, reason: \"contains executable code\"}, \"not packed into asar archive\")\n    }\n\n    addParents(pathInArchive, packageDirPathInArchive)\n  }\n\n  if (dirToCreate.size > 0) {\n    await ensureDir(unpackedDest + path.sep + \"node_modules\")\n    // child directories should be not created asynchronously - parent directories should be created first\n    await BluebirdPromise.map(dirToCreate.keys(), async parentDir => {\n      const base = unpackedDest + path.sep + parentDir\n      await ensureDir(base)\n      await BluebirdPromise.each(dirToCreate.get(parentDir)!, (it): any => {\n        if (dirToCreate.has(parentDir + path.sep + it)) {\n          // already created\n          return null\n        }\n        else {\n          return ensureDir(base + path.sep + it)\n        }\n      })\n    }, CONCURRENCY)\n  }\n}"],"sourceRoot":""}
