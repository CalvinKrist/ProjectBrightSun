{"version":3,"sources":["../../src/asar/integrity.ts"],"names":[],"mappings":";;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;;;;;2CAeO,WAA2B,aAA3B,EAAkD,OAAlD,EAAuF;AAC5F;AACA,UAAM,QAAQ,CAAC,MAAM,yBAAQ,aAAR,CAAP,EAA+B,MAA/B,CAAsC,MAAM,GAAG,QAAH,CAAY,OAAZ,CAA5C,EAAkE,IAAlE,EAAd;AACA,UAAM,YAAY,MAAM,uBAAgB,GAAhB,CAAoB,KAApB,EAA2B,MAAM,SAAS,KAAK,IAAL,CAAU,aAAV,EAAyB,EAAzB,CAAT,CAAjC,CAAxB;AAEA,UAAM,SAAqC,EAA3C;;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAA1B,EAAkC,GAAlC,EAAuC;AACrC,aAAO,MAAM,CAAN,CAAP,IAAmB,UAAU,CAAV,CAAnB;AACD;;AACD,WAAA,OAAA,MAAA,CAAA;AAAQ,iBAAW;AAAnB,KAAA,EAA8B,OAA9B,CAAA;AACD,G;;kBAVqB,W;;;;;;;AAYtB,SAAS,QAAT,CAAkB,IAAlB,EAAgC,YAAoB,QAApD,EAA8D,WAAwC,QAAtG,EAA8G;AAC5G,SAAO,IAAI,OAAJ,CAAoB,CAAC,OAAD,EAAU,MAAV,KAAoB;AAC7C,UAAM,OAAO,0BAAW,SAAX,CAAb;AACA,SACG,EADH,CACM,OADN,EACe,MADf,EAEG,WAFH,CAEe,QAFf;AAIA,gCAAiB,IAAjB,EACG,EADH,CACM,OADN,EACe,MADf,EAEG,EAFH,CAEM,KAFN,EAEa,MAAK;AACd,WAAK,GAAL;AACA,cAAQ,KAAK,IAAL,EAAR;AACD,KALH,EAMG,IANH,CAMQ,IANR,EAMc;AAAC,WAAK;AAAN,KANd;AAOD,GAbM,CAAP;AAcD,C","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { createHash } from \"crypto\"\nimport { createReadStream } from \"fs\"\nimport { readdir } from \"fs-extra-p\"\nimport * as path from \"path\"\n\nexport interface AsarIntegrityOptions {\n  /**\n   * Allows external asar files.\n   *\n   * @default false\n   */\n  readonly externalAllowed?: boolean\n}\n\nexport interface AsarIntegrity extends AsarIntegrityOptions {\n  checksums: { [key: string]: string; }\n}\n\nexport async function computeData(resourcesPath: string, options?: AsarIntegrityOptions | null): Promise<AsarIntegrity> {\n  // sort to produce constant result\n  const names = (await readdir(resourcesPath)).filter(it => it.endsWith(\".asar\")).sort()\n  const checksums = await BluebirdPromise.map(names, it => hashFile(path.join(resourcesPath, it)))\n\n  const result: { [key: string]: string; } = {}\n  for (let i = 0; i < names.length; i++) {\n    result[names[i]] = checksums[i]\n  }\n  return {checksums: result, ...options}\n}\n\nfunction hashFile(file: string, algorithm: string = \"sha512\", encoding: \"hex\" | \"base64\" | \"latin1\" = \"base64\") {\n  return new Promise<string>((resolve, reject) => {\n    const hash = createHash(algorithm)\n    hash\n      .on(\"error\", reject)\n      .setEncoding(encoding)\n\n    createReadStream(file)\n      .on(\"error\", reject)\n      .on(\"end\", () => {\n        hash.end()\n        resolve(hash.read() as string)\n      })\n      .pipe(hash, {end: false})\n  })\n}"],"sourceRoot":""}
