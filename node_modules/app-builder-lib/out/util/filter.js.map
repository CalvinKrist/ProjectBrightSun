{"version":3,"sources":["../../src/util/filter.ts"],"names":[],"mappings":";;;;;;;;;;;;AAKA;AACM,SAAU,QAAV,CAAmB,OAAnB,EAAqC;AACzC,QAAM,MAAM,QAAQ,GAApB;;AACA,MAAI,IAAI,MAAJ,GAAa,CAAjB,EAAoB;AAClB,WAAO,IAAP;AACD;;AAED,OAAK,MAAM,CAAX,IAAgB,IAAI,CAAJ,CAAhB,EAAwB;AACtB,QAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B;AACzB,aAAO,IAAP;AACD;AACF;;AAED,SAAO,KAAP;AACD,C,CAED;;;AACA,SAAS,cAAT,CAAwB,CAAxB,EAAiC;AAC/B,SAAO,EAAE,MAAF,KAAa,CAAb,IAAkB,EAAE,QAAF,CAAW,KAAK,GAAhB,CAAlB,GAAyC,CAAzC,GAA8C,IAAI,KAAK,GAA9D;AACD;AAED;;;AACM,SAAU,YAAV,CAAuB,GAAvB,EAAoC,QAApC,EAAgE,eAAhE,EAAyG;AAC7G,QAAM,gBAAgB,KAAK,GAA3B;AACA,QAAM,kBAAkB,eAAe,GAAf,CAAxB;AACA,SAAO,CAAC,EAAD,EAAK,IAAL,KAAa;AAClB,QAAI,QAAQ,EAAZ,EAAgB;AACd,aAAO,IAAP;AACD;;AAED,QAAI,CAAC,GAAG,UAAH,CAAc,eAAd,CAAL,EAAqC;AACnC,YAAM,IAAI,KAAJ,CAAU,GAAG,EAAE,kBAAkB,eAAe,EAAhD,CAAN;AACD;;AAED,QAAI,WAAW,GAAG,SAAH,CAAa,gBAAgB,MAA7B,CAAf;;AACA,QAAI,kBAAkB,IAAtB,EAA4B;AAC1B,UAAI,SAAS,UAAT,CAAoB,IAApB,CAAJ,EAA+B;AAC7B;AACA,mBAAW,SAAS,SAAT,CAAmB,CAAnB,CAAX;AACD;;AACD,iBAAW,SAAS,OAAT,CAAiB,KAAjB,EAAwB,GAAxB,CAAX;AACD,KAhBiB,CAkBlB;;;AACA,WAAO,aAAa,QAAb,EAAuB,QAAvB,EAAiC,IAAjC,MAA2C,mBAAmB,IAAnB,IAA2B,KAAK,WAAL,EAA3B,IAAiD,CAAC,aAAa,QAAb,EAAuB,eAAvB,EAAwC,IAAxC,CAA7F,CAAP;AACD,GApBD;AAqBD,C,CAED;;;AACA,SAAS,YAAT,CAAsB,IAAtB,EAAoC,QAApC,EAAgE,IAAhE,EAA2E;AACzE,MAAI,QAAQ,KAAZ;;AACA,OAAK,MAAM,OAAX,IAAsB,QAAtB,EAAgC;AAC9B;AACA;AACA,QAAI,UAAU,QAAQ,MAAtB,EAA8B;AAC5B;AACD,KAL6B,CAO9B;AACA;;;AACA,YAAQ,QAAQ,KAAR,CAAc,IAAd,EAAoB,KAAK,WAAL,MAAsB,CAAC,QAAQ,MAAnD,CAAR;AACD;;AACD,SAAO,KAAP;AACD,C","sourcesContent":["import { Filter } from \"builder-util/out/fs\"\nimport { Stats } from \"fs-extra-p\"\nimport { Minimatch } from \"minimatch\"\nimport * as path from \"path\"\n\n/** @internal */\nexport function hasMagic(pattern: Minimatch) {\n  const set = pattern.set\n  if (set.length > 1) {\n    return true\n  }\n\n  for (const i of set[0]) {\n    if (typeof i !== \"string\") {\n      return true\n    }\n  }\n\n  return false\n}\n\n// sometimes, destination may not contain path separator in the end (path to folder), but the src does. So let's ensure paths have path separators in the end\nfunction ensureEndSlash(s: string) {\n  return s.length === 0 || s.endsWith(path.sep) ? s : (s + path.sep)\n}\n\n/** @internal */\nexport function createFilter(src: string, patterns: Array<Minimatch>, excludePatterns?: Array<Minimatch> | null): Filter {\n  const pathSeparator = path.sep\n  const srcWithEndSlash = ensureEndSlash(src)\n  return (it, stat) => {\n    if (src === it) {\n      return true\n    }\n\n    if (!it.startsWith(srcWithEndSlash)) {\n      throw new Error(`${it} must be under ${srcWithEndSlash}`)\n    }\n\n    let relative = it.substring(srcWithEndSlash.length)\n    if (pathSeparator === \"\\\\\") {\n      if (relative.startsWith(\"\\\\\")) {\n        // windows problem: double backslash, the above substring call removes root path with a single slash, so here can me some leftovers\n        relative = relative.substring(1)\n      }\n      relative = relative.replace(/\\\\/g, \"/\")\n    }\n\n    // https://github.com/electron-userland/electron-builder/issues/867\n    return minimatchAll(relative, patterns, stat) && (excludePatterns == null || stat.isDirectory() || !minimatchAll(relative, excludePatterns, stat))\n  }\n}\n\n// https://github.com/joshwnj/minimatch-all/blob/master/index.js\nfunction minimatchAll(path: string, patterns: Array<Minimatch>, stat: Stats): boolean {\n  let match = false\n  for (const pattern of patterns) {\n    // If we've got a match, only re-test for exclusions.\n    // if we don't have a match, only re-test for inclusions.\n    if (match !== pattern.negate) {\n      continue\n    }\n\n    // partial match — pattern: foo/bar.txt path: foo — we must allow foo\n    // use it only for non-negate patterns: const m = new Minimatch(\"!node_modules/@(electron-download|electron)/**/*\", {dot: true }); m.match(\"node_modules\", true) will return false, but must be true\n    match = pattern.match(path, stat.isDirectory() && !pattern.negate)\n  }\n  return match\n}\n"],"sourceRoot":""}
