{"version":3,"sources":["../../src/util/NodeModuleCopyHelper.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { CONCURRENCY } from \"builder-util/out/fs\"\nimport { lstat, readdir } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport { excludedNames, FileMatcher } from \"../fileMatcher\"\nimport { Packager } from \"../packager\"\nimport { resolveFunction } from \"../platformPackager\"\nimport { FileCopyHelper } from \"./AppFileWalker\"\n\nconst excludedFiles = new Set([\".DS_Store\", \"node_modules\" /* already in the queue */, \"CHANGELOG.md\", \"ChangeLog\", \"changelog.md\", \"binding.gyp\", \".npmignore\"].concat(excludedNames.split(\",\")))\nconst topLevelExcludedFiles = new Set([\"test.js\", \"karma.conf.js\", \".coveralls.yml\", \"README.md\", \"readme.markdown\", \"README\", \"readme.md\", \"readme\", \"test\", \"__tests__\", \"tests\", \"powered-test\", \"example\", \"examples\"])\n\n/** @internal */\nexport class NodeModuleCopyHelper extends FileCopyHelper {\n  constructor(matcher: FileMatcher, packager: Packager) {\n    super(matcher, matcher.isEmpty() ? null : matcher.createFilter(), packager)\n  }\n\n  async collectNodeModules(baseDir: string, moduleNames: Iterable<string>, nodeModuleExcludedExts: Array<string>): Promise<Array<string>> {\n    const filter = this.filter\n    const metadata = this.metadata\n\n    const onNodeModuleFile = resolveFunction(this.packager.config.onNodeModuleFile, \"onNodeModuleFile\")\n\n    const result: Array<string> = []\n    const queue: Array<string> = []\n    for (const moduleName of moduleNames) {\n      const tmpPath = baseDir + path.sep + moduleName\n      queue.length = 1\n      // The path should be corrected in Windows that when the moduleName is Scoped packages named.\n      const depPath = path.normalize(tmpPath)\n      queue[0] = depPath\n\n      // if (dep.link != null) {\n      //   this.metadata.set(dep.path, dep.stat!)\n      //   const r = this.handleSymlink(dep.stat!, dep.path, dep.link!)\n      //   if (r != null) {\n      //     await r\n      //   }\n      // }\n\n      while (queue.length > 0) {\n        const dirPath = queue.pop()!\n\n        const childNames = await readdir(dirPath)\n        childNames.sort()\n\n        const isTopLevel = dirPath === depPath\n        const dirs: Array<string> = []\n        // our handler is async, but we should add sorted files, so, we add file to result not in the mapper, but after map\n        const sortedFilePaths = await BluebirdPromise.map(childNames, name => {\n          if (onNodeModuleFile != null) {\n            onNodeModuleFile(dirPath + path.sep + name)\n          }\n\n          if (excludedFiles.has(name) || name.startsWith(\"._\")) {\n            return null\n          }\n\n          for (const ext of nodeModuleExcludedExts) {\n            if (name.endsWith(ext)) {\n              return null\n            }\n          }\n\n          // noinspection SpellCheckingInspection\n          if (isTopLevel && (topLevelExcludedFiles.has(name) || (moduleName === \"libui-node\" && (name === \"build\" || name === \"docs\" || name === \"src\")))) {\n            return null\n          }\n\n          if (dirPath.endsWith(\"build\")) {\n            if (name === \"gyp-mac-tool\" || name === \"Makefile\" || name.endsWith(\".mk\") || name.endsWith(\".gypi\") || name.endsWith(\".Makefile\")) {\n              return null\n            }\n          }\n          else if (dirPath.endsWith(\"Release\") && (name === \".deps\" || name === \"obj.target\")) {\n            return null\n          }\n          else if (name === \"src\" && (dirPath.endsWith(\"keytar\") || dirPath.endsWith(\"keytar-prebuild\"))) {\n            return null\n          }\n          else if (dirPath.endsWith(\"lzma-native\") && (name === \"build\" || name === \"deps\")) {\n            return null\n          }\n\n          const filePath = dirPath + path.sep + name\n          return lstat(filePath)\n            .then(stat => {\n              if (filter != null && !filter(filePath, stat)) {\n                return null\n              }\n\n              if (!stat.isDirectory()) {\n                metadata.set(filePath, stat)\n              }\n              const consumerResult = this.handleFile(filePath, dirPath, stat)\n              if (consumerResult == null) {\n                if (stat.isDirectory()) {\n                  dirs.push(name)\n                  return null\n                }\n                else {\n                  return filePath\n                }\n              }\n              else {\n                return consumerResult\n                  .then(it => {\n                    // asarUtil can return modified stat (symlink handling)\n                    if ((it == null ? stat : it).isDirectory()) {\n                      dirs.push(name)\n                      return null\n                    }\n                    else {\n                      return filePath\n                    }\n                  })\n              }\n            })\n        }, CONCURRENCY)\n\n        for (const child of sortedFilePaths) {\n          if (child != null) {\n            result.push(child)\n          }\n        }\n\n        dirs.sort()\n        for (const child of dirs) {\n          queue.push(dirPath + path.sep + child)\n        }\n      }\n    }\n    return result\n  }\n}"],"sourceRoot":""}
