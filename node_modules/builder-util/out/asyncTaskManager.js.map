{"version":3,"sources":["../src/asyncTaskManager.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEM,MAAO,gBAAP,CAAuB;AAI3B,cAA6B,iBAA7B,EAAiE;AAApC,SAAA,iBAAA,GAAA,iBAAA;AAHpB,SAAA,KAAA,GAA6B,EAA7B;AACQ,SAAA,MAAA,GAAuB,EAAvB;AAGhB;;AAED,MAAI,IAAJ,EAA4B;AAC1B,QAAI,KAAK,iBAAL,IAA0B,IAA1B,IAAkC,CAAC,KAAK,iBAAL,CAAuB,SAA9D,EAAyE;AACvE,WAAK,OAAL,CAAa,MAAb;AACD;AACF;;AAED,UAAQ,OAAR,EAA6B;AAC3B,QAAI,KAAK,iBAAL,CAAuB,SAA3B,EAAsC;AACpC,iBAAI,KAAJ,CAAU;AAAC,gBAAQ,WAAT;AAAsB,eAAO,IAAI,KAAJ,GAAY;AAAzC,OAAV,EAA2D,sBAA3D;;AACA,UAAI,YAAY,OAAhB,EAAyB;AACtB,gBAAgB,MAAhB;AACF;;AACD;AACD;;AAED,SAAK,KAAL,CAAW,IAAX,CAAgB,QACb,KADa,CACP,MAAK;AACV,iBAAI,KAAJ,CAAU;AAAC,eAAO,GAAG,OAAH,IAAc,GAAG,QAAH;AAAtB,OAAV,EAAgD,kBAAhD;;AACA,WAAK,MAAL,CAAY,IAAZ,CAAiB,EAAjB;AACA,aAAO,QAAQ,OAAR,CAAgB,IAAhB,CAAP;AACD,KALa,CAAhB;AAMD;;AAED,gBAAW;AACT,SAAK,MAAM,IAAX,IAAmB,KAAK,KAAxB,EAA+B;AAC7B,UAAI,YAAY,IAAhB,EAAsB;AACnB,aAAa,MAAb;AACF;AACF;;AACD,SAAK,KAAL,CAAW,MAAX,GAAoB,CAApB;AACD;;AAEK,YAAN,GAAgB;AAAA;;AAAA;AACd,UAAI,MAAK,iBAAL,CAAuB,SAA3B,EAAsC;AACpC,cAAK,WAAL;;AACA,eAAO,EAAP;AACD;;AAED,YAAM,cAAc,MAAK;AACvB,YAAI,MAAK,MAAL,CAAY,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,gBAAK,WAAL;;AACA,qBAAW,MAAK,MAAhB;AACA;AACD;AACF,OAND;;AAQA;AAEA,UAAI,SAA4B,IAAhC;AACA,YAAM,QAAQ,MAAK,KAAnB;AACA,UAAI,OAAO,MAAM,KAAN,EAAX;AACA,YAAM,MAAN,GAAe,CAAf;;AACA,aAAO,KAAK,MAAL,GAAc,CAArB,EAAwB;AACtB,cAAM,YAAY,MAAM,QAAQ,GAAR,CAAY,IAAZ,CAAxB;AACA,iBAAS,UAAU,IAAV,GAAiB,SAAjB,GAA6B,OAAO,MAAP,CAAc,SAAd,CAAtC;AACA;;AACA,YAAI,MAAM,MAAN,KAAiB,CAArB,EAAwB;AACtB;AACD,SAFD,MAGK;AACH,cAAI,MAAK,iBAAL,CAAuB,SAA3B,EAAsC;AACpC,kBAAK,WAAL;;AACA,mBAAO,EAAP;AACD;;AAED,iBAAO,MAAM,KAAN,EAAP;AACA,gBAAM,MAAN,GAAe,CAAf;AACD;AACF;;AACD,aAAO,UAAU,EAAjB;AArCc;AAsCf;;AA7E0B;;;;AAgF7B,SAAS,UAAT,CAAoB,MAApB,EAAwC;AACtC,MAAI,OAAO,MAAP,KAAkB,CAAtB,EAAyB;AACvB,UAAM,OAAO,CAAP,CAAN;AACD,GAFD,MAGK,IAAI,OAAO,MAAP,GAAgB,CAApB,EAAuB;AAC1B,UAAM,KAAI,sBAAJ,EAAgB,MAAhB,EAAwB,kBAAxB,CAAN;AACD;AACF,C","sourcesContent":["import { CancellationToken } from \"builder-util-runtime\"\nimport { log } from \"./log\"\nimport { NestedError } from \"./promise\"\n\nexport class AsyncTaskManager {\n  readonly tasks: Array<Promise<any>> = []\n  private readonly errors: Array<Error> = []\n\n  constructor(private readonly cancellationToken: CancellationToken) {\n  }\n\n  add(task: () => Promise<any>) {\n    if (this.cancellationToken == null || !this.cancellationToken.cancelled) {\n      this.addTask(task())\n    }\n  }\n\n  addTask(promise: Promise<any>) {\n    if (this.cancellationToken.cancelled) {\n      log.debug({reason: \"cancelled\", stack: new Error().stack}, \"async task not added\")\n      if (\"cancel\" in promise) {\n        (promise as any).cancel()\n      }\n      return\n    }\n\n    this.tasks.push(promise\n      .catch(it => {\n        log.debug({error: it.message || it.toString()}, \"async task error\")\n        this.errors.push(it)\n        return Promise.resolve(null)\n      }))\n  }\n\n  cancelTasks() {\n    for (const task of this.tasks) {\n      if (\"cancel\" in task) {\n        (task as any).cancel()\n      }\n    }\n    this.tasks.length = 0\n  }\n\n  async awaitTasks(): Promise<Array<any>> {\n    if (this.cancellationToken.cancelled) {\n      this.cancelTasks()\n      return []\n    }\n\n    const checkErrors = () => {\n      if (this.errors.length > 0) {\n        this.cancelTasks()\n        throwError(this.errors)\n        return\n      }\n    }\n\n    checkErrors()\n\n    let result: Array<any> | null = null\n    const tasks = this.tasks\n    let list = tasks.slice()\n    tasks.length = 0\n    while (list.length > 0) {\n      const subResult = await Promise.all(list)\n      result = result == null ? subResult : result.concat(subResult)\n      checkErrors()\n      if (tasks.length === 0) {\n        break\n      }\n      else {\n        if (this.cancellationToken.cancelled) {\n          this.cancelTasks()\n          return []\n        }\n\n        list = tasks.slice()\n        tasks.length = 0\n      }\n    }\n    return result || []\n  }\n}\n\nfunction throwError(errors: Array<Error>) {\n  if (errors.length === 1) {\n    throw errors[0]\n  }\n  else if (errors.length > 1) {\n    throw new NestedError(errors, \"Cannot cleanup: \")\n  }\n}"],"sourceRoot":""}
