{"version":3,"sources":["../src/promise.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEM,SAAU,iBAAV,CAA4B,KAA5B,EAAwC;AAC5C,UAAQ,KAAR,CAAc,iBAAM,GAAN,CAAU,CAAC,MAAM,KAAN,IAAe,KAAhB,EAAuB,QAAvB,EAAV,CAAd;AACA,UAAQ,IAAR,CAAa,CAAb;AACD,C,CAED;;;;2CACO,WAAiC,OAAjC,EAAsD,IAAtD,EAAsG;AAC3G,QAAI,SAAmB,IAAvB;;AACA,QAAI;AACF,eAAS,MAAM,OAAf;AACD,KAFD,CAGA,OAAO,aAAP,EAAsB;AACpB,UAAI;AACF,cAAM,KAAK,IAAL,CAAN;AACD,OAFD,CAGA,OAAO,SAAP,EAAkB;AAChB,cAAM,IAAI,WAAJ,CAAgB,CAAC,aAAD,EAAgB,SAAhB,CAAhB,CAAN;AACD;;AAED,YAAM,aAAN;AACD;;AAED,UAAM,KAAK,KAAL,CAAN;AACA,WAAO,MAAP;AACD,G;;kBAlBqB,c;;;;;;;AAoBhB,MAAO,WAAP,SAA2B,KAA3B,CAAgC;AACpC,cAAY,MAAZ,EAAkC,UAAkB,kBAApD,EAAsE;AACpE,QAAI,IAAI,OAAR;AACA,QAAI,IAAI,CAAR;;AACA,SAAK,MAAM,KAAX,IAAoB,MAApB,EAA4B;AAC1B,YAAM,SAAS,UAAU,GAAG,GAA5B;AACA,WAAK,SAAS,MAAT,GAAkB,IAAI,MAAJ,CAAW,EAAX,CAAlB,GAAmC,IAAnC,GAA0C,MAAO,KAAtD;AACD;;AACD,UAAM,CAAN;AACD;;AATmC;;;;AAYhC,SAAU,oBAAV,CAAkC,OAAlC,EAAqD;AACzD,SAAO,iBAAiB,OAAjB,EAA0B,IAA1B,CAAP;AACD;;AAEK,SAAU,gBAAV,CAA8B,OAA9B,EAAmD,aAAnD,EAAmE;AACvE,SAAO,QACJ,KADI,CACE,KAAI;AACT,QAAI,EAAE,IAAF,KAAW,QAAX,IAAuB,EAAE,IAAF,KAAW,SAAtC,EAAiD;AAC/C,aAAO,aAAP;AACD;;AACD,UAAM,CAAN;AACD,GANI,CAAP;AAOD,C","sourcesContent":["import chalk from \"chalk\"\n\nexport function printErrorAndExit(error: Error) {\n  console.error(chalk.red((error.stack || error).toString()))\n  process.exit(1)\n}\n\n// you don't need to handle error in your task - it is passed only indicate status of promise\nexport async function executeFinally<T>(promise: Promise<T>, task: (isErrorOccurred: boolean) => Promise<any>): Promise<T> {\n  let result: T | null = null\n  try {\n    result = await promise\n  }\n  catch (originalError) {\n    try {\n      await task(true)\n    }\n    catch (taskError) {\n      throw new NestedError([originalError, taskError])\n    }\n\n    throw originalError\n  }\n\n  await task(false)\n  return result\n}\n\nexport class NestedError extends Error {\n  constructor(errors: Array<Error>, message: string = \"Compound error: \") {\n    let m = message\n    let i = 1\n    for (const error of errors) {\n      const prefix = `Error #${i++} `\n      m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error!.stack\n    }\n    super(m)\n  }\n}\n\nexport function orNullIfFileNotExist<T>(promise: Promise<T>): Promise<T | null> {\n  return orIfFileNotExist(promise, null)\n}\n\nexport function orIfFileNotExist<T>(promise: Promise<T>, fallbackValue: T): Promise<T> {\n  return promise\n    .catch(e => {\n      if (e.code === \"ENOENT\" || e.code === \"ENOTDIR\") {\n        return fallbackValue\n      }\n      throw e\n    })\n}"],"sourceRoot":""}
