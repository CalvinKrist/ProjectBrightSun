{"version":3,"sources":["../src/fs.ts"],"names":[],"mappings":"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","sourcesContent":["import BluebirdPromise from \"bluebird-lst\"\nimport { access, chmod, copyFile as _nodeCopyFile, createReadStream, createWriteStream, ensureDir, link, lstat, readdir, readlink, stat, Stats, symlink, unlink, writeFile } from \"fs-extra-p\"\nimport * as path from \"path\"\nimport Mode from \"stat-mode\"\nimport { log } from \"./log\"\nimport { orNullIfFileNotExist } from \"./promise\"\n\nexport const MAX_FILE_REQUESTS = 8\nexport const CONCURRENCY = {concurrency: MAX_FILE_REQUESTS}\n\nexport type AfterCopyFileTransformer = (file: string) => Promise<void>\n\nexport class CopyFileTransformer {\n  constructor(public readonly afterCopyTransformer: AfterCopyFileTransformer) {\n  }\n}\n\nexport type FileTransformer = (file: string) => Promise<null | string | Buffer | CopyFileTransformer> | null | string | Buffer | CopyFileTransformer\nexport type Filter = (file: string, stat: Stats) => boolean\n\nexport function unlinkIfExists(file: string) {\n  return unlink(file)\n    .catch(() => {/* ignore */})\n}\n\nexport async function statOrNull(file: string): Promise<Stats | null> {\n  return orNullIfFileNotExist(stat(file))\n}\n\nexport async function exists(file: string): Promise<boolean> {\n  try {\n    await access(file)\n    return true\n  }\n  catch (e) {\n    return false\n  }\n}\n\nexport interface FileConsumer {\n  consume(file: string, fileStat: Stats, parent: string, siblingNames: Array<string>): any\n\n  /**\n   * @default false\n   */\n  isIncludeDir?: boolean\n}\n\n/**\n * Returns list of file paths (system-dependent file separator)\n */\nexport async function walk(initialDirPath: string, filter?: Filter | null, consumer?: FileConsumer): Promise<Array<string>> {\n  let result: Array<string> = []\n  const queue: Array<string> = [initialDirPath]\n  let addDirToResult = false\n  const isIncludeDir = consumer == null ? false : consumer.isIncludeDir === true\n  while (queue.length > 0) {\n    const dirPath = queue.pop()!\n    if (isIncludeDir) {\n      if (addDirToResult) {\n        result.push(dirPath)\n      }\n      else {\n        addDirToResult = true\n      }\n    }\n\n    const childNames = await readdir(dirPath)\n    childNames.sort()\n\n    let nodeModuleContent: Array<string> | null = null\n\n    const dirs: Array<string> = []\n    // our handler is async, but we should add sorted files, so, we add file to result not in the mapper, but after map\n    const sortedFilePaths = await BluebirdPromise.map(childNames, name => {\n      if (name === \".DS_Store\" || name === \".gitkeep\") {\n        return null\n      }\n\n      const filePath = dirPath + path.sep + name\n      return lstat(filePath)\n        .then(stat => {\n          if (filter != null && !filter(filePath, stat)) {\n            return null\n          }\n\n          const consumerResult = consumer == null ? null : consumer.consume(filePath, stat, dirPath, childNames)\n          if (consumerResult === false) {\n            return null\n          }\n          else if (consumerResult == null || !(\"then\" in consumerResult)) {\n            if (stat.isDirectory()) {\n              dirs.push(name)\n              return null\n            }\n            else {\n              return filePath\n            }\n          }\n          else {\n            return (consumerResult as Promise<any>)\n              .then((it): any => {\n                if (it != null && Array.isArray(it)) {\n                  nodeModuleContent = it\n                  return null\n                }\n\n                // asarUtil can return modified stat (symlink handling)\n                if ((it != null && \"isDirectory\" in it ? (it as Stats) : stat).isDirectory()) {\n                  dirs.push(name)\n                  return null\n                }\n                else {\n                  return filePath\n                }\n              })\n          }\n        })\n    }, CONCURRENCY)\n\n    for (const child of sortedFilePaths) {\n      if (child != null) {\n        result.push(child)\n      }\n    }\n\n    dirs.sort()\n    for (const child of dirs) {\n      queue.push(dirPath + path.sep + child)\n    }\n\n    if (nodeModuleContent != null) {\n      result = result.concat(nodeModuleContent)\n    }\n  }\n\n  return result\n}\n\nconst _isUseHardLink = process.platform !== \"win32\" && process.env.USE_HARD_LINKS !== \"false\" && (require(\"is-ci\") || process.env.USE_HARD_LINKS === \"true\")\n\nexport function copyFile(src: string, dest: string, isEnsureDir = true) {\n  return (isEnsureDir ? ensureDir(path.dirname(dest)) : Promise.resolve())\n    .then(() => copyOrLinkFile(src, dest, null, false))\n}\n\n/**\n * Hard links is used if supported and allowed.\n * File permission is fixed — allow execute for all if owner can, allow read for all if owner can.\n *\n * ensureDir is not called, dest parent dir must exists\n */\nexport function copyOrLinkFile(src: string, dest: string, stats?: Stats | null, isUseHardLink = _isUseHardLink, exDevErrorHandler?: (() => boolean) | null): Promise<any> {\n  if (stats != null) {\n    const originalModeNumber = stats.mode\n    const mode = new Mode(stats)\n    if (mode.owner.execute) {\n      mode.group.execute = true\n      mode.others.execute = true\n    }\n\n    mode.group.read = true\n    mode.others.read = true\n\n    if (originalModeNumber !== stats.mode) {\n      if (log.isDebugEnabled) {\n        const oldMode = new Mode({mode: originalModeNumber})\n        log.debug({file: dest, oldMode, mode}, \"permissions fixed from\")\n      }\n\n      // https://helgeklein.com/blog/2009/05/hard-links-and-permissions-acls/\n      // Permissions on all hard links to the same data on disk are always identical. The same applies to attributes.\n      // That means if you change the permissions/owner/attributes on one hard link, you will immediately see the changes on all other hard links.\n      if (isUseHardLink) {\n        isUseHardLink = false\n        log.debug({dest}, \"copied, but not linked, because file permissions need to be fixed\")\n      }\n    }\n  }\n\n  if (isUseHardLink) {\n    return link(src, dest)\n      .catch(e => {\n        if (e.code === \"EXDEV\") {\n          const isLog = exDevErrorHandler == null ? true : exDevErrorHandler()\n          if (isLog && log.isDebugEnabled) {\n            log.debug({error: e.message}, \"cannot copy using hard link\")\n          }\n          return doCopyFile(src, dest, stats)\n        }\n        else {\n          throw e\n        }\n      })\n  }\n  return doCopyFile(src, dest, stats)\n}\n\nfunction doCopyFile(src: string, dest: string, stats: Stats | null | undefined): Promise<any> {\n  if (_nodeCopyFile == null) {\n    return new Promise((resolve, reject) => {\n      const reader = createReadStream(src)\n      const writer = createWriteStream(dest, stats == null ? undefined : {mode: stats!!.mode})\n      reader.on(\"error\", reject)\n      writer.on(\"error\", reject)\n      writer.on(\"open\", () => {\n        reader.pipe(writer)\n      })\n      writer.once(\"close\", resolve)\n    })\n  }\n\n  // node 8.5.0+\n  const promise = _nodeCopyFile(src, dest)\n  if (stats == null) {\n    return promise\n  }\n\n  return promise\n    .then(() => chmod(dest, stats.mode))\n}\n\nexport class FileCopier {\n  isUseHardLink: boolean\n\n  constructor(private readonly isUseHardLinkFunction?: (file: string) => boolean, private readonly transformer?: FileTransformer | null) {\n    if (isUseHardLinkFunction === USE_HARD_LINKS) {\n      this.isUseHardLink = true\n    }\n    else {\n      this.isUseHardLink = _isUseHardLink && isUseHardLinkFunction !== DO_NOT_USE_HARD_LINKS\n    }\n  }\n\n  async copy(src: string, dest: string, stat: Stats | undefined) {\n    let afterCopyTransformer: AfterCopyFileTransformer | null = null\n    if (this.transformer != null && stat != null && stat.isFile()) {\n      let data = this.transformer(src)\n      if (data != null) {\n        if (typeof data === \"object\" && \"then\" in data) {\n          data = await data\n        }\n\n        if (data != null) {\n          if (data instanceof CopyFileTransformer) {\n            afterCopyTransformer = data.afterCopyTransformer\n          }\n          else {\n            await writeFile(dest, data)\n            return\n          }\n        }\n      }\n    }\n\n    const isUseHardLink = afterCopyTransformer == null && ((!this.isUseHardLink || this.isUseHardLinkFunction == null) ? this.isUseHardLink : this.isUseHardLinkFunction(dest))\n    await copyOrLinkFile(src, dest, stat, isUseHardLink, isUseHardLink ? () => {\n      // files are copied concurrently, so, we must not check here currentIsUseHardLink — our code can be executed after that other handler will set currentIsUseHardLink to false\n      if (this.isUseHardLink) {\n        this.isUseHardLink = false\n        return true\n      }\n      else {\n        return false\n      }\n    } : null)\n\n    if (afterCopyTransformer != null) {\n      await afterCopyTransformer(dest)\n    }\n  }\n}\n\nexport interface CopyDirOptions {\n  filter?: Filter | null\n  transformer?: FileTransformer | null\n  isUseHardLink?: (file: string) => boolean\n}\n\n/**\n * Empty directories is never created.\n * Hard links is used if supported and allowed.\n */\nexport function copyDir(src: string, destination: string, options: CopyDirOptions = {}): Promise<any> {\n  const fileCopier = new FileCopier(options.isUseHardLink, options.transformer)\n\n  if (log.isDebugEnabled) {\n    log.debug({src, destination}, `copying${fileCopier.isUseHardLink ? \" using hard links\" : \"\"}`)\n  }\n\n  const createdSourceDirs = new Set<string>()\n  const links: Array<Link> = []\n  return walk(src, options.filter, {\n    consume: async (file, stat, parent) => {\n      if (!stat.isFile() && !stat.isSymbolicLink()) {\n        return\n      }\n\n      if (!createdSourceDirs.has(parent)) {\n        await ensureDir(parent.replace(src, destination))\n        createdSourceDirs.add(parent)\n      }\n\n      const destFile = file.replace(src, destination)\n      if (stat.isFile()) {\n        await fileCopier.copy(file, destFile, stat)\n      }\n      else {\n        links.push({file: destFile, link: await readlink(file)})\n      }\n    }\n  })\n    .then(() => BluebirdPromise.map(links, it => symlink(it.link, it.file), CONCURRENCY))\n}\n\nexport const DO_NOT_USE_HARD_LINKS = (file: string) => false\nexport const USE_HARD_LINKS = (file: string) => true\n\nexport interface Link {\n  readonly link: string,\n  readonly file: string\n}"],"sourceRoot":""}
