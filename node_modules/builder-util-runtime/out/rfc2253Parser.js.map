{"version":3,"sources":["../src/rfc2253Parser.ts"],"names":[],"mappings":";;;;;;;AAAM,SAAA,OAAA,CAAkB,GAAlB,EAA6B;AACjC,MAAI,SAAS,KAAb;AACA,MAAI,MAAqB,IAAzB;AACA,MAAI,QAAQ,EAAZ;AACA,MAAI,eAAe,CAAnB;AAEA,QAAM,IAAI,IAAJ,EAAN;AACA,QAAM,SAAS,IAAI,GAAJ,EAAf;;AACA,OAAK,IAAI,IAAI,CAAb,EAAgB,KAAK,IAAI,MAAzB,EAAiC,GAAjC,EAAsC;AACpC,QAAI,MAAM,IAAI,MAAd,EAAsB;AACpB,UAAI,QAAQ,IAAZ,EAAkB;AAChB,eAAO,GAAP,CAAW,GAAX,EAAgB,KAAhB;AACD;;AACD;AACD;;AAED,UAAM,KAAK,IAAI,CAAJ,CAAX;;AACA,QAAI,MAAJ,EAAY;AACV,UAAI,OAAO,GAAX,EAAgB;AACd,iBAAS,KAAT;AACA;AACD;AACF,KALD,MAMK;AACH,UAAI,OAAO,GAAX,EAAgB;AACd,iBAAS,IAAT;AACA;AACD;;AAED,UAAI,OAAO,IAAX,EAAiB;AACf;AACA,cAAM,MAAM,SAAS,IAAI,KAAJ,CAAU,CAAV,EAAa,IAAI,CAAjB,CAAT,EAA8B,EAA9B,CAAZ;;AACA,YAAI,OAAO,KAAP,CAAa,GAAb,CAAJ,EAAuB;AACrB,mBAAS,IAAI,CAAJ,CAAT;AACD,SAFD,MAGK;AACH;AACA,mBAAS,OAAO,YAAP,CAAoB,GAApB,CAAT;AACD;;AACD;AACD;;AAED,UAAI,QAAQ,IAAR,IAAgB,OAAO,GAA3B,EAAgC;AAC9B,cAAM,KAAN;AACA,gBAAQ,EAAR;AACA;AACD;;AAED,UAAI,OAAO,GAAP,IAAc,OAAO,GAArB,IAA4B,OAAO,GAAvC,EAA4C;AAC1C,YAAI,QAAQ,IAAZ,EAAkB;AAChB,iBAAO,GAAP,CAAW,GAAX,EAAgB,KAAhB;AACD;;AACD,cAAM,IAAN;AACA,gBAAQ,EAAR;AACA;AACD;AACF;;AAED,QAAI,OAAO,GAAP,IAAc,CAAC,MAAnB,EAA2B;AACzB,UAAI,MAAM,MAAN,KAAiB,CAArB,EAAwB;AACtB;AACD;;AAED,UAAI,IAAI,YAAR,EAAsB;AACpB,YAAI,IAAI,CAAR;;AACA,eAAO,IAAI,CAAJ,MAAW,GAAlB,EAAuB;AACrB;AACD;;AACD,uBAAe,CAAf;AACD;;AAED,UAAI,gBAAgB,IAAI,MAApB,IACC,IAAI,YAAJ,MAAsB,GADvB,IAEC,IAAI,YAAJ,MAAsB,GAFvB,IAGE,QAAQ,IAAR,IAAgB,IAAI,YAAJ,MAAsB,GAHxC,IAIE,QAAQ,IAAR,IAAgB,IAAI,YAAJ,MAAsB,GAJ5C,EAKE;AACA,YAAI,eAAe,CAAnB;AACA;AACD;AACF;;AAED,aAAS,EAAT;AACD;;AAED,SAAO,MAAP;AACD,C","sourcesContent":["export function parseDn(seq: string): Map<string, string> {\n  let quoted = false\n  let key: string | null = null\n  let token = \"\"\n  let nextNonSpace = 0\n\n  seq = seq.trim()\n  const result = new Map<string, string>()\n  for (let i = 0; i <= seq.length; i++) {\n    if (i === seq.length) {\n      if (key !== null) {\n        result.set(key, token)\n      }\n      break\n    }\n\n    const ch = seq[i]\n    if (quoted) {\n      if (ch === '\"') {\n        quoted = false\n        continue\n      }\n    }\n    else {\n      if (ch === '\"') {\n        quoted = true\n        continue\n      }\n\n      if (ch === \"\\\\\") {\n        i++\n        const ord = parseInt(seq.slice(i, i + 2), 16)\n        if (Number.isNaN(ord)) {\n          token += seq[i]\n        }\n        else {\n          i++\n          token += String.fromCharCode(ord)\n        }\n        continue\n      }\n\n      if (key === null && ch === \"=\") {\n        key = token\n        token = \"\"\n        continue\n      }\n\n      if (ch === \",\" || ch === \";\" || ch === \"+\") {\n        if (key !== null) {\n          result.set(key, token)\n        }\n        key = null\n        token = \"\"\n        continue\n      }\n    }\n\n    if (ch === \" \" && !quoted) {\n      if (token.length === 0) {\n        continue\n      }\n\n      if (i > nextNonSpace) {\n        let j = i\n        while (seq[j] === \" \") {\n          j++\n        }\n        nextNonSpace = j\n      }\n\n      if (nextNonSpace >= seq.length\n        || seq[nextNonSpace] === \",\"\n        || seq[nextNonSpace] === \";\"\n        || (key === null && seq[nextNonSpace] === \"=\")\n        || (key !== null && seq[nextNonSpace] === \"+\")\n      ) {\n        i = nextNonSpace - 1\n        continue\n      }\n    }\n\n    token += ch\n  }\n\n  return result\n}"],"sourceRoot":""}
