{"version":3,"sources":["../src/xml.ts"],"names":[],"mappings":"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","sourcesContent":["import * as sax from \"sax\"\nimport { newError } from \"./index\"\n\nexport class XElement {\n  value = \"\"\n  attributes: { [key: string]: string } | null = null\n  isCData = false\n  elements: Array<XElement> | null = null\n\n  constructor(readonly name: string) {\n    if (!name) {\n      throw newError(\"Element name cannot be empty\", \"ERR_XML_ELEMENT_NAME_EMPTY\")\n    }\n    if (!isValidName(name)) {\n      throw newError(`Invalid element name: ${name}`, \"ERR_XML_ELEMENT_INVALID_NAME\")\n    }\n  }\n\n  attribute(name: string): string {\n    const result = this.attributes === null ? null : this.attributes[name]\n    if (result == null) {\n      throw newError(`No attribute \"${name}\"`, \"ERR_XML_MISSED_ATTRIBUTE\")\n    }\n    return result\n  }\n\n  removeAttribute(name: string): void {\n    if (this.attributes !== null) {\n      delete this.attributes[name]\n    }\n  }\n\n  element(name: string, ignoreCase = false, errorIfMissed: string | null = null): XElement {\n    const result = this.elementOrNull(name, ignoreCase)\n    if (result === null) {\n      throw newError(errorIfMissed || `No element \"${name}\"`, \"ERR_XML_MISSED_ELEMENT\")\n    }\n    return result\n  }\n\n  elementOrNull(name: string, ignoreCase = false): XElement | null {\n    if (this.elements === null) {\n      return null\n    }\n\n    for (const element of this.elements) {\n      if (isNameEquals(element, name, ignoreCase)) {\n        return element\n      }\n    }\n\n    return null\n  }\n\n  getElements(name: string, ignoreCase = false) {\n    if (this.elements === null) {\n      return []\n    }\n    return this.elements.filter(it => isNameEquals(it, name, ignoreCase))\n  }\n\n  elementValueOrEmpty(name: string, ignoreCase = false): string {\n    const element = this.elementOrNull(name, ignoreCase)\n    return element === null ? \"\" : element.value\n  }\n}\n\nconst NAME_REG_EXP = new RegExp(/^[A-Za-z_][:A-Za-z0-9_-]*$/i)\n\nfunction isValidName(name: string) {\n  return (NAME_REG_EXP.test(name))\n}\n\nfunction isNameEquals(element: XElement, name: string, ignoreCase: boolean) {\n  const elementName = element.name\n  return elementName === name || (ignoreCase === true && elementName.length === name.length && elementName.toLowerCase() === name.toLowerCase())\n}\n\nexport function parseXml(data: string): XElement {\n  let rootElement: XElement | null = null\n  const parser = sax.parser(true, {})\n  const elements: Array<XElement> = []\n\n  parser.onopentag = saxElement => {\n    const element = new XElement(saxElement.name)\n    element.attributes = saxElement.attributes as { [key: string]: string }\n\n    if (rootElement === null) {\n      rootElement = element\n    }\n    else {\n      const parent = elements[elements.length - 1]\n      if (parent.elements == null) {\n        parent.elements = []\n      }\n      parent.elements.push(element)\n    }\n    elements.push(element)\n  }\n\n  parser.onclosetag = () => {\n    elements.pop()\n  }\n\n  parser.ontext = text => {\n    if (elements.length > 0) {\n      elements[elements.length - 1].value = text\n    }\n  }\n\n  parser.oncdata = cdata => {\n    const element = elements[elements.length - 1]\n    element.value = cdata\n    element.isCData = true\n  }\n\n  parser.onerror = err => {\n    throw err\n  }\n\n  parser.write(data)\n  return rootElement!!\n}"],"sourceRoot":""}
